= Динамическая память и реализация динамического массива в C
:source-highlighter: rouge
:rouge-style: github
:icons: font
:sectnums:
:centered:
:max-width: 900px

== Введение в динамическую память

При создании массива с фиксированными размерами под него выделяется определенная память. Например, пусть у нас будет массив с пятью элементами:

[source, c, align="center"]
----
double numbers[5] = {1.0, 2.0, 3.0, 4.0, 5.0};
----
Для такого массива выделяется память 5 * 8 (размер типа double) = 40 байт. Таким образом, мы точно знаем, сколько в массиве элементов и сколько он занимает памяти. Однако это не всегда удобно. Иногда бывает необходимо, чтобы количество элементов и соответственно размер выделяемой памяти для массива определялись динамически в зависимости от некоторых условий. Например, пользователь сам может вводить размер массива. И в этом случае для создания массива мы можем использовать динамическое выделение памяти.

== Основные функции для работы с динамической памятью


Для управления динамическим выделением памяти используется ряд функций, определённых в заголовочном файле `stdlib.h`:

* `malloc()`
+
[source, c]
----
void *malloc(unsigned s);
----
Выделяет память длиной в `s` байт и возвращает указатель на начало выделенной памяти.  
В случае неудачи возвращает `NULL`.

* `calloc()`
+
[source, c]
----
void *calloc(unsigned n, unsigned m);
----
Выделяет память для `n` элементов по `m` байт каждый и возвращает указатель на начало выделенной памяти.  
В случае неудачи возвращает `NULL`.

* `realloc()`
+
[source, c]
----
void *realloc(void *bl, unsigned ns);
----
Изменяет размер ранее выделенного блока памяти, на начало которого указывает указатель `bl`, до размера `ns` байт.  
Если указатель `bl` равен `NULL`, то действие функции аналогично `malloc`.

* `free()`
+
[source, c]
----
void free(void *bl);
----
Освобождает ранее выделенный блок памяти, на начало которого указывает указатель `bl`.

=== malloc() - выделение памяти


**Параметры:**
- `size` - количество байт для выделения

**Возвращает:**
- Указатель на выделенный блок памяти при успехе
- `NULL` при неудаче

Функция malloc() выделяет память длиной для определенного количества байт и возвращает указатель на начало выделенной памяти. Через полученный указатель мы можем помещать данные в выделенную память. Рассмотрим простой пример:
[source, c]
----
#include <stdio.h>
#include <stdlib.h>   // для подключения функции malloc
 
int main(void)
{
    int *ptr = (int*)malloc(sizeof(int)); // выделяем память для одного int
    *ptr = 24;      // помещаем значение в выделенную память
 
    printf("%d \n", *ptr);
    free(ptr);
}
----

Здесь с помощью функции malloc выделяется память для одного объекта int. Чтобы узнать, сколько байтов надо выделить, передаем в функцию malloc размер типа int на текущей и в результате получаем указатель ptr, который указывает на выделенную память

[NOTE]
====
Прямое приведение типов из `malloc` (например `(int*)malloc(sizeof(int))`) в языке C **не обязательно**,
так как `void*` автоматически преобразуется в любой указатель.  
Однако многие программисты всё же используют приведение типов для явности или при совместимости с C++.  
====

Далее я не буду использовать приведение типов

Стоит отметить, что теоретически мы можем столкнуться с тем, что функции malloc() не удастся выделить требуемую память, и тогда она возвратит NULL. Чтобы избежать подобной ситуации перед использованием указателя мы можем проверять его на значение NULL:

[source, c, align="center"]
----
#include <stdio.h>
#include <stdlib.h>   // для подключения функции malloc
 
int main(void)
{
    int *ptr = malloc(sizeof(int)); // выделяем память для одного int
    if(ptr != NULL)
    {
        *ptr = 24;      // помещаем значение в выделенную память
        printf("%d \n", *ptr);
    }
    free(ptr);
}
----

Немотря на освобождение памяти с помощью функции free() указатель сохраняет свой адрес, и теоретически мы можем обращаться к памяти по данному указателю. Однако полученные значения уже будут неопределенными и недетеминированными. Поэтому некоторые советуют после освобождения памяти также устанавливать для указателя значение NULL:

[source, c, align="center"]
----
free(ptr);
ptr = NULL;
----
[IMPORTANT]
====
Память, выделенная через `malloc()`, содержит случайные данные (мусор). 
Обязательно инициализируйте выделенную память перед использованием!
====

=== calloc() - выделение обнуленной памяти

**Параметры:**
- `num` - количество элементов
- `size` - размер каждого элемента в байтах

**Возвращает:**
- Указатель на выделенный и обнуленный блок памяти
- `NULL` при неудаче

Функция calloc() имеет прототип
[source, c]
----
void *calloc(unsigned n, unsigned m);
----

Она выделяет память для n элементов по m байт каждый и возвращает указатель на начало выделенной памяти. В случае неудачного выполнения возвращает NULL

В отличие от функции malloc() она инициализирует все выделенные байты памяти нулями. Например, выделим память для одного объекта int:

[source, c, align="center"]
----
#include <stdio.h>
#include <stdlib.h>
 
int main(void)
{
    // выделяем память для одного объекта int
    int *ptr = calloc(1, sizeof(int));
    if(ptr)
    {
        // получаем значение по умолчанию - 0
        printf("Initial value: %d\n", *ptr);  // Initial value: 0
        // устанавливаем новое значение
        *ptr = 15;
        // получаем новое значение
        printf("New value: %d\n", *ptr);      // New value: 15
    }
 
    free(ptr);
    return 0;
}
----

Консольный вывод:

[source, shell, align="center"]
----
❯ gcc exemple.c -o app && ./app && rm app

Initial value: 0
New value: 15
----

Подобным образом можно выделить память и для других объектов. Например, выделим память для массива из 4-х объектов int:
[source, c, align="center"]
----
#include <stdio.h>
#include <stdlib.h>
 
int main(void)
{
    // выделяем память для 4-х объектов int
    int n = 4;
    int *ptr = calloc(n, sizeof(int));
    if(ptr)
    {
        // устанавливаем значения
        ptr[0] = 1;
        ptr[1] = 2;
        ptr[2] = 3;
        ptr[3] = 5;
        // получаем значения
        for(int i = 0; i < n; i++)
        {
            printf("%d", ptr[i]);
        }
    }
 
    free(ptr);
}
----

=== realloc() - изменение размера блока памяти

**Параметры:**
- `ptr` - указатель на ранее выделенный блок (может быть `NULL`)
- `new_size` - новый размер в байтах

**Возвращает:**
- Указатель на блок памяти нового размера
- `NULL` при неудаче (старый блок остается неизменным)

Функция realloc() позволяет изменить размер памяти, ранее выделенной с помощью функций malloc() b calloc(). Имеет прототип
[source, c]
----
void *realloc(void *bl, unsigned ns);
----
Первый параметр представляет указатель на ранее выделенный блок памяти. А второй параметр представляет новый размер блока памяти в байтах.

Если указатель bl имеет значение NULL, то есть память не выделялась, то действие функции аналогично действию malloc

Рассмотрим небольшой пример:

[source, c, align="center"]
----
#include <stdio.h>
#include <stdlib.h>
 
int main(void)
{
    // выделяем память для 1-го объекта int
    int size = sizeof(int);
    int *ptr = malloc(size);
    if(ptr)
    {
        // отображаем адрес и размер памяти
        printf("Addresss: %p \t Size: %d\n", (void*)ptr, size);
    }
    // расширяем память до размера 4-х объектов int
    size = 4 * sizeof(int);
    int *ptr_new = realloc(ptr, size);
    // если выделение памяти прошло успещно
    if(ptr_new)
    {
        printf("Reallocation\n");
        // заново отображаем адрес и размер памяти
        printf("Addresss: %p \t Size: %d\n", (void*)ptr_new, size);
        free(ptr_new);  // освобождаем новый указатель
    }
    else
    {
        free(ptr);  // освобождаем старый указатель
    }
}
----

Здесь сначала выделяем память для одного объекта int с помощью функции malloc.

[source, c, align="center"]
----
int size = sizeof(int);
int *ptr = malloc(size);
----

Если память успешно выделена, то выводим на консоль адрес и размер выделенного блока памяти. Затем с помощью функции realloc расширяем память до 4 объектов int

[source, c, align="center"]
----
size = 4 * sizeof(int);
int *ptr_new = realloc(ptr, size);
----

Если увеличение памяти прошло успешно, то заново выводим данные на консоль и освобождаем память по новому указателю. Если увеличение памяти прошло не удачно, то освобождаем память но старому указателю.

Консольный вывод в моем случае

[source, shell, align="center"]
----
❯ gcc exemple.c -o app && ./app && rm app
Addresss: 0x62b92a0 	Size: 4
Reallocation
Addresss: 0x62b92a0 	Size: 16
----

Стоит отметить, что нам необязательно создавать новый указатель, мы можем присвоить значение старому указателю:
[source, c, align="center"]
----
#include <stdio.h>
#include <stdlib.h>
 
int main(void)
{
    int size = sizeof(int);
    int *ptr = malloc(size);
    if(ptr)
    {
        printf("Addresss: %p \t Allocated: %d\n", (void*)ptr, size);
    }
    size = 4 * sizeof(int);
    ptr = realloc(ptr, size);   // используем старый указатель
    if(ptr)
    {
        printf("Reallocation\n");
        printf("Addresss: %p \t Allocated: %d\n", (void*)ptr, size);
    }
    free(ptr);
}
----

[IMPORTANT]
====
Сохранение возвращаемого значения realoc может быть небезопасно, ведь в случае ошибки на наш указатель будет переписан NULL значением и мы потеряем данные лучше сохранить в буфферную зону и сделать проверку
====

=== free() - освобождение памяти

Функция `free()` освобождает ранее выделенный блок памяти.


**Параметры:**
- `ptr` - указатель на освобождаемый блок памяти

free(). Имеет прототип
[source, c, align="center"]
----
void *free(void *bl);
----

**Пример использования:**

[source, c]
----
int* ptr = malloc(sizeof(int));
// ... работа с памятью
free(ptr);
ptr = NULL; // Хорошая практика - обнулить указатель
----

[IMPORTANT]
====
**Правила работы с `free()`:**

1. Каждый `malloc()`, `calloc()` или `realloc()` должен иметь соответствующий `free()`
2. Нельзя вызывать `free()` дважды для одного блока памяти
3. Нельзя использовать память после вызова `free()`
4. `free(NULL)` безопасен и ничего не делает
====

== Типичные ошибки при работе с динамической памятью

=== Утечки памяти (Memory Leaks)

Происходят, когда выделенная память не освобождается:

[source, c]
----
// ПЛОХО: утечка памяти
void bad_function() {
    int* ptr = malloc(sizeof(int));
    *ptr = 42;
    return; // Забыли вызвать free(ptr)!
}
----

=== Использование после освобождения (Use After Free)

[source, c]
----
// ПЛОХО: использование освобожденной памяти
int* ptr = malloc(sizeof(int));
*ptr = 42;
free(ptr);
printf("%d\n", *ptr); // Ошибка! Память уже освобождена
----

=== Двойное освобождение (Double Free)

[source, c]
----
// ПЛОХО: двойное освобождение
int* ptr = malloc(sizeof(int));
free(ptr);
free(ptr); // Ошибка! Повторное освобождение
----

=== Переполнение буфера

[source, c]
----
// ПЛОХО: запись за границы выделенной памяти
int* array = malloc(5 * sizeof(int));
array[10] = 42; // Ошибка! Обращение за границы массива
----

== Лучшие практики

1. **Всегда проверяйте результат выделения памяти на `NULL`**
2. **Обнуляйте указатели после освобождения памяти**
3. **Используйте инструменты для поиска утечек памяти** (Valgrind, AddressSanitizer)
4. **Симметрично вызывайте malloc/free**
5. **Инициализируйте выделенную память перед использованием**

[source, c]
----
// ХОРОШО: правильная работа с памятью
int* allocate_array(size_t count) {
    int* array = malloc(count * sizeof(int));
    if (!array) {
        fprintf(stderr, "Ошибка выделения памяти\n");
        return NULL;
    }
    
    // Инициализируем память
    for (size_t i = 0; i < count; i++) {
        array[i] = 0;
    }
    
    return array;
}

void cleanup_array(int** array) {
    if (array && *array) {
        free(*array);
        *array = NULL; // Обнуляем указатель
    }
}
----

== Функции работы с памятью

Помимо функций для работы со строками, библиотека `string.h` содержит важные функции для работы с произвольными блоками памяти. Эти функции особенно полезны при управлении динамической памятью.

==== `memset` - заполнение памяти

Заполняет блок памяти определённым значением.

[source, c]
----
void* memset(void* ptr, int value, size_t num);
----

* `ptr` - указатель на начало блока памяти
* `value` - значение для заполнения (приводится к `unsigned char`)
* `num` - количество байт для заполнения

[source, c]
----
int arr[10];
memset(arr, 0, sizeof(arr));        // обнуляем весь массив
memset(arr, -1, sizeof(arr));       // заполняем всеми единицами (0xFF)

char buffer[100];
memset(buffer, 'A', 50);            // заполняем первые 50 байт символом 'A'
----

[WARNING]
====
`memset` работает с байтами! Для инициализации массива `int` нулями используйте `memset(arr, 0, sizeof(arr))`. Для других значений лучше использовать цикл.
====

==== `memcpy` - копирование блоков памяти

Копирует блок памяти из источника в назначение.

[source, c]
----
void* memcpy(void* dest, const void* src, size_t num);
----

* `dest` - указатель на блок-назначение
* `src` - указатель на блок-источник  
* `num` - количество байт для копирования

[source, c]
----
int src[] = {1, 2, 3, 4, 5};
int dest[5];
memcpy(dest, src, sizeof(src));     // копируем весь массив

// Копирование части структуры
vector* v1 = createVector();
vector* v2 = createVector(); 
memcpy(v2, v1, sizeof(vector));     // копируем всю структуру
----

[IMPORTANT]
====
`memcpy` не проверяет пересечение блоков памяти. Если блоки пересекаются, поведение не определено. Используйте `memmove` для пересекающихся блоков.
====

==== `memcmp` - сравнение блоков памяти

Сравнивает два блока памяти побайтно.

[source, c]
----
int memcmp(const void* ptr1, const void* ptr2, size_t num);
----

Возвращает:
* `0` - блоки одинаковы
* `< 0` - первый блок "меньше" второго
* `> 0` - первый блок "больше" второго

[source, c]
----
int arr1[] = {1, 2, 3, 4, 5};
int arr2[] = {1, 2, 3, 4, 5};
int arr3[] = {1, 2, 3, 4, 6};

if (memcmp(arr1, arr2, sizeof(arr1)) == 0) {
    printf("Массивы одинаковы\n");
}

if (memcmp(arr1, arr3, sizeof(arr1)) != 0) {
    printf("Массивы различаются\n");
}
----

==== `memmove` - безопасное копирование

Копирует блок памяти с учётом возможного пересечения блоков.

[source, c]
----
void* memmove(void* dest, const void* src, size_t num);
----

[source, c]
----
int arr[] = {1, 2, 3, 4, 5, 6, 7, 8};
// Сдвигаем элементы в пределах одного массива
memmove(&arr[2], &arr[0], 4 * sizeof(int));  // {1, 2, 1, 2, 3, 4, 7, 8}
----

[TIP]
====
Функции `mem*` работают на уровне байтов и часто быстрее циклов, так как оптимизированы на аппаратном уровне. Используйте их для массовых операций с памятью.
====

В практической части работы я пока не буду использовать mem* функций для того, чтобы вы пока закрепленили базовые функции, но в конце приведу пример оптимизаций при помощи оных 

== Практика

=== Создание своего вектора/списка/динамического массива

Те, кто никогда не писал на C, удивляются отсутствию такой, казалось бы, банальной вещи, как динамический массив.

В отличие от языков высокого уровня (Python, Java, C++), где есть встроенные динамические структуры данных, в C программист должен реализовывать их самостоятельно. Это даёт полный контроль над управлением памятью, но требует понимания низкоуровневых операций.

Теперь, воспользовавшись полученными знаниями, мы напишем собственную реализацию динамического массива.

=== Определяем структуру массива

Динамический массив должен хранить:

* количество элементов (`size`) - текущее количество хранящихся элементов
* вместимость (`capacity`) - максимальное количество элементов, которое может поместиться в выделенной памяти
* указатель на выделенную память (`data`) - адрес начала массива данных

[source, c]
----
typedef struct vector {
    size_t size;       // количество элементов
    size_t capacity;   // вместимость массива
    int* data;         // указатель на данные
} vector;
----

[NOTE]
====
Разделение `size` и `capacity` позволяет избежать частых перераспределений памяти. Когда `size < capacity`, можно добавлять элементы без вызова `malloc`/`realloc`.
====

=== Создание массива

На первом шаге необходимо выделить память под саму структуру и массив данных.
Задаём начальную вместимость, например `4`.

[source, c]
----
vector* createVector() {
    int initial_size = 4;  // начальная вместимость
    
    // Выделяем память под структуру vector
    vector* arr = malloc(sizeof(vector));
    if (!arr) {
        fprintf(stderr, "Memory allocation failed\n");
        return NULL;
    }
    
    // Выделяем память под массив данных
    arr->data = malloc(initial_size * sizeof(int));
    if (!arr->data) {
        free(arr);  // Освобождаем уже выделенную память
        fprintf(stderr, "Memory allocation failed\n");
        return NULL;
    }
    
    // Инициализируем поля структуры
    arr->size = 0;
    arr->capacity = initial_size;
    return arr;
}
----

[IMPORTANT]
====
Обратите внимание на проверку результата `malloc`. Если выделение памяти под `data` не удалось, мы освобождаем уже выделенную память под `arr`, чтобы избежать утечки памяти.
====

=== Освобождение памяти

Чтобы не допустить утечек памяти, нужно освободить как данные, так и саму структуру.

[source, c]
----
int freeArray(vector** arr) {
    // Проверяем, что передан валидный указатель
    if (!arr || !*arr) {
        fprintf(stderr, "Array is NULL\n");
        return -1;
    }
    
    // Освобождаем массив данных
    free((*arr)->data);
    
    // Освобождаем структуру
    free(*arr);
    
    // Обнуляем указатель для предотвращения повторного использования
    *arr = NULL;
    return 1;
}
----

[NOTE]
====
Функция принимает указатель на указатель (`vector**`), чтобы обнулить исходный указатель. Это предотвращает случайное использование освобождённой памяти.
====

=== Автоматическое расширение массива

Если при добавлении элемента массив переполнен, нужно увеличить его `capacity` с помощью `realloc()`.

[source, c]
----
int autoResizeArray(vector* arr) {
    if (!arr) {
        fprintf(stderr, "Array is NULL\n");
        return -1;
    }
    
    // Пытаемся увеличить размер в 2 раза
    int* newData = realloc(arr->data, arr->capacity * 2 * sizeof(int));
    if (!newData) {
        fprintf(stderr, "Memory reallocation failed\n");
        return -1;
    }
    
    // Обновляем указатель и вместимость
    arr->data = newData;
    arr->capacity *= 2;
    return 1;
}
----

[WARNING]
====
Никогда не сохраняйте результат `realloc()` сразу в исходный указатель!  
В случае ошибки вы потеряете ссылку на старый блок памяти и создадите утечку.

Неправильно:
```c
arr->data = realloc(arr->data, new_size); // Потеря данных при ошибке!
```

Правильно:
```c
int* newData = realloc(arr->data, new_size);
if (newData) {
    arr->data = newData;
}
```
====

[TIP]
====
Стратегия увеличения в 2 раза обеспечивает амортизированную сложность O(1) для операции добавления элемента. Это стандартный подход в большинстве реализаций динамических массивов.
====

=== Основные операции

==== Добавление элемента в конец (`pushBack`)

[source, c]
----
int pushBack(vector* arr, int value) {
    if (!arr) {
        fprintf(stderr, "Array is NULL\n");
        return -1;
    }
    
    // Проверяем, нужно ли расширять массив
    if (arr->size >= arr->capacity) {
        if (autoResizeArray(arr) == -1) {
            return -1;  // Не удалось расширить
        }
    }
    
    // Добавляем элемент в конец
    arr->data[arr->size] = value;
    arr->size++;
    return 1;
}
----

Временная сложность: O(1) амортизированная, O(n) в худшем случае (при расширении).

==== Удаление элемента с конца (`popBack`)

[source, c]
----
int popBack(vector* arr) {
    if (!arr) {
        fprintf(stderr, "Array is NULL\n");
        return -1;
    }
    
    // Проверяем, есть ли элементы для удаления
    if (arr->size == 0) {
        fprintf(stderr, "Array is empty\n");
        return -1;
    }
    
    // Просто уменьшаем размер (элемент остаётся в памяти, но считается удалённым)
    arr->size--;
    return 1;
}
----

[NOTE]
====
Мы не обнуляем удалённый элемент, так как он находится за границей `size`. При следующем добавлении элемента он будет перезаписан.
====

Временная сложность: O(1).

==== Вставка по индексу (`insertByIndex`)

[source, c]
----
int insertByIndex(vector* arr, int index, int val) {
    if (!arr) {
        fprintf(stderr, "Vector is NULL\n");
        return -1;
    }
    
    // Проверяем корректность индекса
    if (index < 0 || index > arr->size) {
        fprintf(stderr, "Index out of bounds\n");
        return -1;
    }
    
    // Расширяем массив при необходимости
    if (arr->size >= arr->capacity) {
        if (autoResizeArray(arr) == -1) {
            return -1;
        }
    }
    
    // Сдвигаем элементы вправо
    for (int i = arr->size; i > index; i--) {
        arr->data[i] = arr->data[i - 1];
    }
    
    // Вставляем новый элемент
    arr->data[index] = val;
    arr->size++;
    return 1;
}
----

[IMPORTANT]
====
Обратите внимание: индекс может быть равен `size` (вставка в конец), поэтому условие `index <= arr->size`.

Цикл идёт от конца к позиции вставки, чтобы не перезаписать данные.
====

Временная сложность: O(n) из-за необходимости сдвигать элементы.

==== Удаление по индексу (`removeByIndex`)

[source, c]
----
int removeByIndex(vector* arr, int index) {
    if (!arr) {
        fprintf(stderr, "Array is NULL\n");
        return -1;
    }
    
    // Проверяем корректность индекса
    if (index < 0 || index >= arr->size) {
        fprintf(stderr, "Index out of bounds\n");
        return -1;
    }
    
    // Сдвигаем элементы влево, перезаписывая удаляемый элемент
    for (int i = index; i < arr->size - 1; i++) {
        arr->data[i] = arr->data[i + 1];
    }
    
    arr->size--;
    return 1;
}
----

[NOTE]
====
В отличие от вставки, здесь индекс не может быть равен `size`, так как такого элемента не существует.
====

Временная сложность: O(n) из-за необходимости сдвигать элементы.

==== Получение размера (`getSize`)

[source, c]
----
size_t getSize(vector* arr) {
    if (!arr) {
        return 0;  // Или можно вернуть SIZE_MAX как индикатор ошибки
    }
    return arr->size;
}
----

Временная сложность: O(1).

==== Печать массива (`printArray`)

[source, c]
----
int printArray(vector* arr) {
    if (!arr) {
        fprintf(stderr, "Array is NULL\n");
        return -1;
    }
    
    printf("Vector[%zu/%zu]: ", arr->size, arr->capacity);
    for (int i = 0; i < arr->size; i++) {
        printf("%d ", arr->data[i]);
    }
    printf("\n");
    return 1;
}
----

[TIP]
====
Полезно выводить и размер, и вместимость для отладки. Это помогает понять, когда происходят расширения массива.
====

=== Пример использования

[source, c]
----
int main() {
    // Создаём пустой вектор
    vector* arr = createVector();
    if (!arr) {
        return 1;  // Ошибка создания
    }
    
    // Добавляем числа от 1 до 10
    for (int i = 1; i <= 10; i++) {
        pushBack(arr, i);
    }
    printArray(arr); // Vector[10/16]: 1 2 3 4 5 6 7 8 9 10
    
    // Вставляем 99 на позицию 5
    insertByIndex(arr, 5, 99);
    printArray(arr); // Vector[11/16]: 1 2 3 4 5 99 6 7 8 9 10
    
    // Удаляем элемент с позиции 2
    removeByIndex(arr, 2);
    printArray(arr); // Vector[10/16]: 1 2 4 5 99 6 7 8 9 10
    
    // Удаляем последний элемент
    popBack(arr);
    printArray(arr); // Vector[9/16]: 1 2 4 5 99 6 7 8 9
    
    // Освобождаем память
    freeArray(&arr);
    
    // arr теперь равен NULL
    printf("arr after free: %p\n", (void*)arr);
    
    return 0;
}
----

=== Анализ сложности операций

[cols="2,1,3"]
|===
|Операция |Сложность |Комментарий

|`pushBack` |O(1)* |Амортизированная сложность
|`popBack` |O(1) |Всегда константное время
|`insertByIndex` |O(n) |Нужно сдвигать элементы
|`removeByIndex` |O(n) |Нужно сдвигать элементы
|`getSize` |O(1) |Просто возврат поля
|===

* Амортизированная сложность означает, что в среднем операция выполняется за O(1), но иногда может потребовать O(n) времени для расширения массива.

== Оптимизируем некотрые функции, а также добавим новые при помощи mem* функций 

[source, c]
----
// Быстрая очистка вектора
int fastClear(vector* arr) {
    if (!arr) return -1;
    memset(arr->data, 0, arr->capacity * sizeof(int));
    arr->size = 0;
    return 1;
}

// Копирование вектора
vector* copyVector(const vector* src) {
    if (!src) return NULL;
    
    vector* dest = createVector();
    if (!dest) return NULL;
    
    // Расширяем до нужного размера
    while (dest->capacity < src->size) {
        if (autoResizeArray(dest) == -1) {
            freeArray(&dest);
            return NULL;
        }
    }
    
    // Копируем данные одной операцией
    memcpy(dest->data, src->data, src->size * sizeof(int));
    dest->size = src->size;
    
    return dest;
}

// Сравнение векторов
int compareVectors(const vector* v1, const vector* v2) {
    if (!v1 || !v2) return -2;  // ошибка
    if (v1->size != v2->size) return -1;  // разные размеры
    
    return memcmp(v1->data, v2->data, v1->size * sizeof(int));
}
----


== Контрольные задания

=== 1. Функция `getByIndex`

Реализовать функцию `getByIndex(vector* arr, int index)`, возвращающую элемент массива по индексу.

[source, c]
----
// Возвращает элемент по индексу или INT_MIN при ошибке
int getByIndex(vector* arr, int index) {
    // TODO: добавить проверки и вернуть элемент
    // Подсказка: проверить arr на NULL и границы индекса
}
----

[TIP]
====
Подумайте, как обработать ошибки. Можно возвращать специальное значение (например, `INT_MIN`) или использовать указатель на результат.
====

=== 2. Функция `clear`

Реализовать функцию `clear(vector* arr)`, которая обнуляет размер массива (size = 0), но не освобождает память.

[source, c]
----
int clear(vector* arr) {
    // TODO: обнулить size, сохранив capacity и data
}
----

[NOTE]
====
Эта операция полезна для переиспользования вектора без перевыделения памяти.
====

=== 3. Функция `shrinkToFit`

Добавить функцию `shrinkToFit(vector* arr)`, уменьшающую capacity до текущего размера.

[source, c]
----
int shrinkToFit(vector* arr) {
    // TODO: использовать realloc для уменьшения capacity до size
    // Подсказка: обработать случай size = 0
}
----

[WARNING]
====
Будьте осторожны с `realloc` при размере 0. Некоторые реализации могут вести себя по-разному.
====

=== 4. Программа с удалением каждого второго элемента

Написать программу, которая:

* создаёт массив
* добавляет числа 1–10
* удаляет каждый второй элемент
* выводит результат

[source, c]
----
int main() {
    vector* arr = createVector();
    
    // TODO: добавить числа 1-10
    
    // TODO: удалить каждый второй элемент
    // Подсказка: будьте осторожны с изменением индексов при удалении
    
    // TODO: вывести результат и освободить память
    
    return 0;
}
----

[IMPORTANT]
====
При удалении элементов в цикле индексы сдвигаются. Рассмотрите два подхода:

1. Идти с конца массива
2. Корректировать индекс после каждого удаления
====

=== Дополнительные задания (по желанию)

==== 5. Оптимизация памяти

Модифицируйте функции так, чтобы `capacity` автоматически уменьшалась, когда `size` становится в 4 раза меньше `capacity`.

==== 6. Обобщение типов

Перепишите вектор для работы с `void*` вместо `int`, добавив функции сравнения и копирования.

==== 7. Итераторы

Реализуйте простые итераторы для прохода по вектору:

[source, c]
----
typedef struct vector_iterator {
    int* current;
    int* end;
} vector_iterator;

vector_iterator begin(vector* arr);
vector_iterator end(vector* arr);
int hasNext(vector_iterator* it);
int next(vector_iterator* it);
----

=== Заключение

Создание собственного динамического массива демонстрирует:

* Управление памятью с помощью `malloc`, `realloc`, `free`
* Стратегии роста для эффективности
* Обработку ошибок и граничных случаев
* Важность тестирования всех операций

Эта реализация является упрощённой версией `std::vector` из C++ или `ArrayList` из Java. В реальных библиотеках добавляются оптимизации, обобщения типов и дополнительная функциональность.